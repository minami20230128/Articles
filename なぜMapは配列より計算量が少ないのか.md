# なぜMapは配列より計算量が少ないのか
## 調べようと思ったきっかけ
業務でパフォーマンスチューニングを行った際、配列からfilterで線形探索を行うよりも予めMapを作成しておいたほうが計算量が減ることを知った。  
しかし、Mapであっても結局全要素の中から指定したキーを探さなければならないはず。なぜ計算量がO(1)になるのだろう？と気になったため。

## 結論
Mapはキーのハッシュ値でバリューを管理しているので、キーを指定するとハッシュ関数を通して（ほぼ）一発で目的の要素を求めることができるから。  

## Mapの仕組み
**ハッシュテーブル**（キーのハッシュ値を添え字とした配列）というデータ構造を使っている。  

![ハッシュテーブル](/images/ハッシュテーブル.png)
出典：https://codezine.jp/article/detail/6396  

Mapに新しい要素を登録すると、キーをハッシュ関数に通し、求まったハッシュ値の位置に新要素を格納する。  
Map.get()を実行して特定の要素を取得するときも、同じハッシュ関数を使って求めたハッシュ値で探す。  
ただし、**異なるキー同士のハッシュ値が重複する場合も可能性**もゼロではない。この場合は同じハッシュ値の要素の中からキーが一致するものを線形探索する。  
このため、O(1)というのはあくまで平均であり、基本的には一発で求まるが必ずしもそうではない。  

## 疑問
- キーをハッシュ化して求めた添字で特定要素にアクセスすると、結局同じ添字の要素を探すのに線形探索することになるんじゃないの？  
配列の添字を指定すると、探しているデータの番地を計算して直接アクセスできるため、O(1)となる。

- Map・Setを使うことのデメリットはあるか  
Yes。  
MapやSetがパフォーマンス向上につながるのは、Listの要素数が多いときに限られる。  
可読性・メモリ使用量を犠牲にすることになるので、置き換えは必要なときだけにすべき。 

例：JavaScriptで100000個の要素を持つList・Mapを初期化したとき
```
const before = process.memoryUsage().heapUsed;

// 処理
const arr = Array(100000).fill(0).map((_, i) => i);
const map = new Map(arr.map(x => [x, x]));

const after = process.memoryUsage().heapUsed;
console.log((after - before) / 1024 / 1024, 'MB');
```
そのまま実行したときの出力結果が15.33563232421875 MBだったのに対し、  
const map~の行を消去した場合の出力結果は1.4641265869140625 MB。