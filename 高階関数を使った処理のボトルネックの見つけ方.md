# 高階関数を使った処理のボトルネックの見つけ方
## 調べようと思ったきっかけ
業務で最適化を行ったとき、高階関数を使った処理はfor文と違って一目で計算量がわからず、  
どのような考え方をすればいいんだろう？と思ったこと。  

## 高階関数とは？
map()、reduce()、filter()など1行で配列を扱える関数。  

## 考え方
その関数がどのような処理をしているかを考えることで、計算量を推測できる。  
- 配列の全要素を必ず一回舐めるもの
map...全要素に同じ操作をする
```
arr.map(x => x * 2)  
```
filter...全要素の中から当てはまる要素だけを抜き出す
```
arr.filter(x => x > 0)
```
- 最悪ケースでは全要素舐めるもの
find...ある条件を満たす、配列内で一番最初の要素を返す
```
arr.find(x => x === target)
```

## ボトルネックを探すときのテクニック
JavaScriptの場合、以下を検索。（正規表現）
\.(map|filter|reduce|flatMap|forEach|find|some|every)\s*\(
- 高階関数内でまた高階関数を使っているパターン
```
a.map(x => b.map(y => ...))
a.map(x => b.find(y => y.id === x.id))
```
- チェーンが長い
```
a.filter(...).map(...).filter(...).map(...)
```
- 別関数の中で更に高階関数を使っているパターン
```
arr.map(別関数)
```
（この場合は別関数の中身を見る）

## 対処法
find、includesをSet/Map化することで計算量を減らせる。  
例えば以下の関数は、bの後方にidがx.idと一致する要素がある場合、O(n * m)になりやすい。  

```
a.map(x => b.find(y => y.id === x.id))
```
bをSet化（重複のないidのみの組み合わせ）し、Set.has()を使用するとO(n + m)で済む。
```
const bSet = new Set(b.map(v => v.id))
const out = a.filter(x => bSet.has(x.id))
```
存在するかどうかを知りたい->Set  
keyからValueを取り出したい->Map